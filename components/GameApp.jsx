/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 ./public/model_2.glb 
*/
import * as THREE from 'three';
import React, { createContext, useContext, useEffect, useRef, useState } from 'react'
import { useAnimations, useGLTF, useTexture } from '@react-three/drei'
import { useFrame } from '@react-three/fiber';
import { appContext } from '../src/App';
import { CustomCounter } from './utils';
import { AudioManage } from './audioComp';
import { Brick_1_Model } from './BrickModels';

export const HandModelContext = createContext(null);
export const BrickManagerContext = createContext(null);
export function HandModel(props) {
  const _appContext = useContext(appContext);
  const group = React.useRef()
  let buttonClicked = useRef(false);
  let brickManagerFunc = useRef(null);
  const { nodes, materials,animations } = useGLTF('/model_2.glb');
  let handModeRef = useRef(null)
  const {actions} = useAnimations(animations,group)
  let [txt,supportTXT] = useTexture(['handtxt1.jpg','supportTXT.jpg']);
  let passedTime = useRef(0);
  let stopHandNormalAnimation = useRef(false)
  txt.flipY = false;
  txt.colorSpace = THREE.SRGBColorSpace; 
  txt.minFilter = THREE.LinearFilter;
  txt.magFilter = THREE.LinearFilter;
  supportTXT.flipY = false;
  supportTXT.colorSpace = THREE.SRGBColorSpace; 
  supportTXT.minFilter = THREE.LinearFilter;
  supportTXT.magFilter = THREE.LinearFilter;

  let modelTxt = new THREE.MeshBasicMaterial({map:txt});
  let supportMat = new THREE.MeshBasicMaterial({map:supportTXT});
  let handBox = new THREE.MeshBasicMaterial({wireframe:true,color:'white',visible:false});
  let startAnimation = true
  let timer = 0;
  let handRotateSpeed = 1/200
  let yDistance = 0.2,speed = 1/8;
  let handMoveObj = {start:false,type:'none',speed:8}
  let brick = {brake:true}
  let startHandMove = (type)=>
    { 

          if(!buttonClicked.current)
          {
            if(type == 'success')
            {
              handMoveObj.type ='success'
            }
            else
            {
              handMoveObj.type ='fail'
            }
            handModeRef.current.position.y = 15;
            stopHandNormalAnimation.current = true;
            buttonClicked.current = true;
            handMoveObj.start = true
            
          }

      
      
    }
  let resetHandPosition = (args)=>
    {
      
      brick.brake = brick.brake? false : true
    
      handModeRef.current.visible = false;
      handModeRef.current.position.y = 12;
      if(args == 'RESTART'){}
      else if(args == 'NEXT')
      {   _appContext.setOnce.current = false;
          _appContext.Level.current ++;
      }
      brickManagerFunc.current('RESET-BRICK');
      
    }
  let handMove = ()=>
    {
      
      if(handMoveObj.start)
      {
        if(handMoveObj.type == 'success')
        {
            if(handModeRef.current.position.y <= 1)
            { AudioManage.play('punch');
              // console.log('casser')
              handMoveObj.start = false;
              brickManagerFunc.current('BREAKE-BRICK');
            }
            else
            {
              // handMoveObj.speed = handMoveObj.speed*1.05;
              handModeRef.current.position.y -= 0.1*handMoveObj.speed;
            }
        }
        else if(handMoveObj.type == 'fail')
        {
            if(handModeRef.current.position.y <= 4.2)
            { AudioManage.play('punch-fail')
              handMoveObj.start = false;
              brickManagerFunc.current('SHAKE-BRICK');
            }
            else
            {
              // handMoveObj.speed = handMoveObj.speed*1.05;
              handModeRef.current.position.y -= 0.1*handMoveObj.speed;
            }
        }
        
        
      }
    }
  let effectAfterbrickIsReady = ()=>
    { 
    
      
      if(!_appContext.setOnce.current)
      {
        if(_appContext.Level.current == 5)
        {
          _appContext.cursorManagerControllerFunc.current('REDUCE-SUCCESS')
        }
        else if(_appContext.Level.current == 7)
        {
          
          _appContext.cursorControllerFunc.current('INCREASE-SPEED')
        }
        else
        {
          _appContext.canClickOnButton.current = true;
        }
        _appContext.setOnce.current = true;
      }
      else
      {
        _appContext.canClickOnButton.current = true;
      }
      
      _appContext.cursorControllerFunc.current('restart');
      _appContext.cursorControllerFunc.current(true);
      buttonClicked.current = false
      handModeRef.current.visible = true;
      stopHandNormalAnimation.current = false
    }
  let handNormalAnimation = ()=>
    {
      if(!stopHandNormalAnimation.current)
        {
          handModeRef.current.position.y += (Math.sin(passedTime.current))/60
        }
      
    }
  useFrame(()=>
    {
      passedTime.current += 1/20;
      handMove()
      handNormalAnimation()
      
    })
  useEffect(()=>
    {
      _appContext.StartHandMoveFunc.current = (args)=>{startHandMove(args)} ;
    },[])
  return (
    <HandModelContext.Provider
      value={{resetHandPosition,effectAfterbrickIsReady,brickManagerFunc}}
    >
     
        <group ref={group} {...props} dispose={null}>
          
              <mesh name='HAND-BOX' ref={handModeRef} visible={false} geometry={nodes.hand_1_box.geometry} material={handBox} position={[0.5,12,0]}>
                    <mesh rotation={[0,Math.PI,Math.PI]}  geometry={nodes.hand_1.geometry} material={modelTxt} position={[-0.3,2.3,0.2]} >
                            <mesh geometry={nodes.hand_1.geometry} scale={1.03}>
                                    <meshBasicMaterial visible={false} color={'red'} side={THREE.BackSide} />
                            </mesh>
                    </mesh>
              </mesh>
              <mesh name="support" geometry={nodes.support.geometry} material={supportMat} position={[-0.254, -1, 0.246]} />
              <BrickManager />
        </group>
    </HandModelContext.Provider>
  )
}


function BrickManager()
{
  let _handModelContext = useContext(HandModelContext)
  let _appContext = useContext(appContext)
  let brickModelFunctions = useRef(null);
  const BrickArray = useRef([<Brick_1_Model level={1} key={0} />,
                              <Brick_1_Model level={2} key={1} />
                              // <Brick_2_Model key={1} />
                            ])
  let [brickModel,setBrickModel] = useState(<Brick_1_Model level={_appContext.Level.current} />);
  let brickManagerFunctions = (args)=>
    {
      // if(args == 'DROP-BRICK')
      // {
      //   setBrickModel(c => c = null);

      //   let resetBrickCounter = new CustomCounter(20,0,()=>{setBrickModel(c => c = <Brick_1_Model />); return true},null);
      //   resetBrickCounter.start();
      // }
       if(args == 'BREAKE-BRICK')
      { 
        brickModelFunctions.current("brake");
      }
      else if(args == 'SHAKE-BRICK')
      { 
        brickModelFunctions.current("no-brake");
      }
      else if(args == 'RESET-BRICK')
      {
        setBrickModel(c => c = null);

        let resetBrickCounter = new CustomCounter(20,0,()=>{setBrickModel(c => c = <Brick_1_Model level={_appContext.Level.current} /> ); return true},null);
        resetBrickCounter.start();
      }
      
    }
  useEffect(()=>
    {
      _handModelContext.brickManagerFunc.current = (args)=>
        {
          brickManagerFunctions(args)
        } 
    },[])
  return(
          <>
              <BrickManagerContext.Provider
                value={{brickModelFunctions}}
              >
              {brickModel}
              </BrickManagerContext.Provider>
          </>
  )
}

useGLTF.preload('/model_2.glb')
//On pourra mÃªme jouer en fonction de la distance

//BONUS la barre devient rapide et petite et le cube brille mais si on arrive a le briser on gagne beaucoup